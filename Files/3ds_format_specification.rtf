{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;}{\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f22\fswiss\fcharset238\fprq2 Arial CE;}{\f23\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f25\fswiss\fcharset161\fprq2 Arial Greek;}{\f26\fswiss\fcharset162\fprq2 Arial Tur;}{\f27\fswiss\fcharset186\fprq2 Arial Baltic;}{\f28\fmodern\fcharset238\fprq1 Courier New CE;}{\f29\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f31\fmodern\fcharset161\fprq1 Courier New Greek;}{\f32\fmodern\fcharset162\fprq1 Courier New Tur;}{\f33\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f40\froman\fcharset238\fprq2 Times CE;}{\f41\froman\fcharset204\fprq2 Times Cyr;}
{\f43\froman\fcharset161\fprq2 Times Greek;}{\f44\froman\fcharset162\fprq2 Times Tur;}{\f45\froman\fcharset186\fprq2 Times Baltic;}{\f46\fswiss\fcharset238\fprq2 Helvetica CE;}{\f47\fswiss\fcharset204\fprq2 Helvetica Cyr;}
{\f49\fswiss\fcharset161\fprq2 Helvetica Greek;}{\f50\fswiss\fcharset162\fprq2 Helvetica Tur;}{\f51\fswiss\fcharset186\fprq2 Helvetica Baltic;}{\f106\fswiss\fcharset238\fprq2 Tahoma CE;}{\f107\fswiss\fcharset204\fprq2 Tahoma Cyr;}
{\f109\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f110\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f111\fswiss\fcharset186\fprq2 Tahoma Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\sb100\sa100\nowidctlpar\adjustright \lang2057 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\adjustright \lang2057 \sbasedon0 \snext16 Definition Term;}{
\s16\li360\nowidctlpar\adjustright \lang2057 \sbasedon0 \snext15 Definition List;}{\*\cs17 \additive \i Definition;}{\s18\sb100\sa100\keepn\nowidctlpar\outlinelevel1\adjustright \b\fs48\lang2057\kerning36 \sbasedon0 \snext0 H1;}{
\s19\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 \sbasedon0 \snext0 H2;}{\s20\sb100\sa100\keepn\nowidctlpar\outlinelevel3\adjustright \b\fs28\lang2057 \sbasedon0 \snext0 H3;}{
\s21\sb100\sa100\keepn\nowidctlpar\outlinelevel4\adjustright \b\lang2057 \sbasedon0 \snext0 H4;}{\s22\sb100\sa100\keepn\nowidctlpar\outlinelevel5\adjustright \b\fs20\lang2057 \sbasedon0 \snext0 H5;}{
\s23\sb100\sa100\keepn\nowidctlpar\outlinelevel6\adjustright \b\fs16\lang2057 \sbasedon0 \snext0 H6;}{\s24\nowidctlpar\adjustright \i\lang2057 \sbasedon0 \snext0 Address;}{\s25\li360\ri360\sb100\sa100\nowidctlpar\adjustright \lang2057 \sbasedon0 \snext25 
Blockquote;}{\*\cs26 \additive \i CITE;}{\*\cs27 \additive \f2\fs20 CODE;}{\*\cs28 \additive \i \sbasedon10 Emphasis;}{\*\cs29 \additive \ul\cf10 \sbasedon10 Hyperlink;}{\*\cs30 \additive \ul\cf12 \sbasedon10 FollowedHyperlink;}{\*\cs31 \additive 
\b\f2\fs20 Keyboard;}{\s32\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\tx9590\adjustright \f2\fs20\lang2057 \sbasedon0 \snext32 Preformatted;}{\s33\qc\nowidctlpar\brdrt\brdrdb\brdrw5\brdrcf1 \adjustright 
\v\f1\fs16\lang2057 \snext0 \shidden z-Bottom of Form;}{\s34\qc\nowidctlpar\brdrb\brdrdb\brdrw5\brdrcf1 \adjustright \v\f1\fs16\lang2057 \snext0 \shidden z-Top of Form;}{\*\cs35 \additive \f2 Sample;}{\*\cs36 \additive \b \sbasedon10 Strong;}{\*\cs37 
\additive \f2\fs20 Typewriter;}{\*\cs38 \additive \i Variable;}{\*\cs39 \additive \v\cf6 HTML Markup;}{\*\cs40 \additive \v Comment;}}{\*\revtbl {Unknown;}}{\info{\title Autodesk 3D Studio File Format}{\author Paul}{\operator BenH}{\creatim\yr2001\mo9\dy10\hr9\min43}
{\revtim\yr2001\mo9\dy10\hr9\min43}{\version2}{\edmins0}{\nofpages53}{\nofwords8692}{\nofchars49547}{\*\company  }{\nofcharsws60847}{\vern89}}{\*\userprops {\propname HTML}\proptype11{\staticval 1}{\propname DocumentEncoding}\proptype30{\staticval 
windows-1252}}\paperw11906\paperh16838\margl1273\margr1273\margt1417\margb1134 \widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind5\viewscale100 \fet0{\*\background 
{\shp{\*\shpinst\shpleft0\shptop0\shpright0\shpbottom0\shpfhdr0\shpbxmargin\shpbymargin\shpwr0\shpwrk0\shpfblwtxt1\shpz0\shplid1025{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}
{\sp{\sn fFilled}{\sv 1}}{\sp{\sn lineWidth}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fBackground}{\sv 1}}}}}\sectd \linex0\headery1440\footery1440\colsx709\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}\pard\plain \s18\qc\sb100\sa100\keepn\nowidctlpar\outlinelevel1\adjustright \b\fs48\lang2057\kerning36 {3D Studio File Format (3ds).
\par }\pard\plain \s19\qc\sb100\sa100\keepn\nowidctlpar\outlinelevel2\adjustright \b\fs36\lang2057 {Autodesk Ltd.
\par }\pard\plain \qc\sb100\sa100\nowidctlpar\adjustright \lang2057 {Document Revision 0.93 - January 1997 
\par }\pard\plain \s32\nowidctlpar\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\adjustright \f2\fs20\lang2057 {
\par 
\par                           3D-Studio File Format (.3ds)
\par                                  Autodesk Ltd.
\par 
\par 
\par                    Document Revision 0.93 - January 1997
\par 
\par    Rewritten by Martin van Velsen (email: vvelsen@ronix.ptf.hro.nl )
\par    and Robin Fercoq ( 3ds-bin + mli )(email: robin@msrwww.fc-net.fr)
\par    Based on documentation by Jim Pitts ( email: jim@micronetics.com )
\par    Source update provided by: 
\par          Albert Szilvasy (email: szilvasy@almos.vein.hu )
\par 
\par    A lot of the chunks are still undocumented if you know what they do
\par    please email me Martin van Velsen, Robin Feroq or Jimm Pitts. 
\par    As I get more information on the file format, I will document it for 
\par    everyone to see. I will post this regurlarly to alt.3d and alt.3d-studio 
\par    and I can be contacted there if my email does not work.
\par 
\par    (Also see the 3d-studio material .mli documentation by Robin Feroq.)
\par 
\par    Disclaimer.
\par    This document describes the file format of the 3ds files generated by
\par    3d-studio by Autodesk. By using the information contained within, you 
\par    agree not to hold any of the authors liable if, from its use, you 
\par    f^Hmuck something up. OK?
\par 
\par    Autodesk has at not yet released the offical specifications of the 
\par    3d-studio formats. You will therefor receive NO support from Autodesk 
\par    or any company related to Autodesk concerning the nature and contents 
\par    of the 3d-studio binary .3ds and .mli formats.
\par 
\par    A warning beforehand. This docs describes the format of 3ds files 
\par    produced by version 3.0 and higher of 3d-studio. You can find this 
\par    version information at byte 29 in the binary file.
\par 
\par    This document can be found on the regular newsgroups:
\par    alt.3d and alt.3d-studio
\par    It can also be found at: "http://www.mediatel.lu"
\par 
\par    -------------------------------------------------------------------------
\par     
\par 
\par 
\par                                   Contents 
\par 
\par 
\par    1. Introduction
\par    2. Chunks anyone ?
\par    3. 3D Editor chunks
\par    4. Keyframer chunks
\par    5. CODE
\par 
\par 
\par 
\par                               1. Introduction
\par                           ======================
\par 
\par    The 3ds file format is made up of chunks. They describe what information
\par    is to follow and what it is made up of, it's ID and the location of the
\par    next block. If you don't understand a chunk you can quite simply skip it.
\par    The next chunk pointer is relative to the start of the current chunk and
\par    in bytes. The binary information in the 3ds file is written in a special
\par    kind of way. Namely the lest significant byte comes first in an int.
\par    For example: 4A 5C  (2 bytes in hex) would be 5C high byte and 4A low 
\par    byte. In a long it is: 4A 5C 3B 8F where 5C4A is the low word and 8F 3B 
\par    is the high word. And now for the chunks. A chunk is defined as:
\par 
\par    start end size name
\par    0     1   2    Chunk ID
\par    2     5   4    Pointer to next chunk relative to the place where
\par                   Chunk ID is, in other words the length of the chunk
\par 
\par    Chunks have a hierarchy imposed on them that is identified byt it's ID.
\par    A 3ds file has the Primary chunk ID 4D4Dh. This is always the first
\par    chunk of the file. Within the primary chunk are the main chunks.
\par 
\par    to give you a preview and a reference to the hierarchy of chunks, 
\par    below is a diagram to show the diffrent chunk ID's and their place 
\par    in the file. The chunks are given a name because below the diagram is 
\par    a list which defines the names to the actual chunk id's. This makes it 
\par    easier to put it in some source code ( how convenient that some sample 
\par    code is included )
\par 
\par 
\par                   MAIN3DS  (0x4D4D)
\par                   |
\par                   +--EDIT3DS  (0x3D3D)
\par                   |  |
\par                   |  +--EDIT_MATERIAL (0xAFFF)
\par                   |  |  |
\par                   |  |  +--MAT_NAME01 (0xA000) (See mli Doc) 
\par                   |  |
\par                   |  +--EDIT_CONFIG1  (0x0100)
\par                   |  +--EDIT_CONFIG2  (0x3E3D) 
\par                   |  +--EDIT_VIEW_P1  (0x7012)
\par                   |  |  |
\par                   |  |  +--TOP            (0x0001)
\par                   |  |  +--BOTTOM         (0x0002)
\par                   |  |  +--LEFT           (0x0003)
\par                   |  |  +--RIGHT          (0x0004)
\par                   |  |  +--FRONT          (0x0005) 
\par                   |  |  +--BACK           (0x0006)
\par                   |  |  +--USER           (0x0007)
\par                   |  |  +--CAMERA         (0xFFFF)
\par                   |  |  +--LIGHT          (0x0009)
\par                   |  |  +--DISABLED       (0x0010)  
\par                   |  |  +--BOGUS          (0x0011)
\par                   |  |
\par                   |  +--EDIT_VIEW_P2  (0x7011)
\par                   |  |  |
\par                   |  |  +--TOP            (0x0001)
\par                   |  |  +--BOTTOM         (0x0002)
\par                   |  |  +--LEFT           (0x0003)
\par                   |  |  +--RIGHT          (0x0004)
\par                   |  |  +--FRONT          (0x0005) 
\par                   |  |  +--BACK           (0x0006)
\par                   |  |  +--USER           (0x0007)
\par                   |  |  +--CAMERA         (0xFFFF)
\par                   |  |  +--LIGHT          (0x0009)
\par                   |  |  +--DISABLED       (0x0010)  
\par                   |  |  +--BOGUS          (0x0011)
\par                   |  |
\par                   |  +--EDIT_VIEW_P3  (0x7020)
\par                   |  +--EDIT_VIEW1    (0x7001) 
\par                   |  +--EDIT_BACKGR   (0x1200) 
\par                   |  +--EDIT_AMBIENT  (0x2100)
\par                   |  +--EDIT_OBJECT   (0x4000)
\par                   |  |  |
\par                   |  |  +--OBJ_TRIMESH   (0x4100)      
\par                   |  |  |  |
\par                   |  |  |  +--TRI_VERTEXL          (0x4110) 
\par                   |  |  |  +--TRI_VERTEXOPTIONS    (0x4111)
\par                   |  |  |  +--TRI_MAPPINGCOORS     (0x4140) 
\par                   |  |  |  +--TRI_MAPPINGSTANDARD  (0x4170)
\par                   |  |  |  +--TRI_FACEL1           (0x4120)
\par                   |  |  |  |  |
\par                   |  |  |  |  +--TRI_SMOOTH            (0x4150)   
\par                   |  |  |  |  +--TRI_MATERIAL          (0x4130)
\par                   |  |  |  |
\par                   |  |  |  +--TRI_LOCAL            (0x4160)
\par                   |  |  |  +--TRI_VISIBLE          (0x4165)
\par                   |  |  |
\par                   |  |  +--OBJ_LIGHT    (0x4600)
\par                   |  |  |  |
\par                   |  |  |  +--LIT_OFF              (0x4620)
\par                   |  |  |  +--LIT_SPOT             (0x4610) 
\par                   |  |  |  +--LIT_UNKNWN01         (0x465A) 
\par                   |  |  | 
\par                   |  |  +--OBJ_CAMERA   (0x4700)
\par                   |  |  |  |
\par                   |  |  |  +--CAM_UNKNWN01         (0x4710)
\par                   |  |  |  +--CAM_UNKNWN02         (0x4720)  
\par                   |  |  |
\par                   |  |  +--OBJ_UNKNWN01 (0x4710)
\par                   |  |  +--OBJ_UNKNWN02 (0x4720)
\par                   |  |
\par                   |  +--EDIT_UNKNW01  (0x1100)
\par                   |  +--EDIT_UNKNW02  (0x1201) 
\par                   |  +--EDIT_UNKNW03  (0x1300)
\par                   |  +--EDIT_UNKNW04  (0x1400)
\par                   |  +--EDIT_UNKNW05  (0x1420)
\par                   |  +--EDIT_UNKNW06  (0x1450)
\par                   |  +--EDIT_UNKNW07  (0x1500)
\par                   |  +--EDIT_UNKNW08  (0x2200)
\par                   |  +--EDIT_UNKNW09  (0x2201)
\par                   |  +--EDIT_UNKNW10  (0x2210)
\par                   |  +--EDIT_UNKNW11  (0x2300)
\par                   |  +--EDIT_UNKNW12  (0x2302)
\par                   |  +--EDIT_UNKNW13  (0x2000)
\par                   |  +--EDIT_UNKNW14  (0xAFFF)
\par                   |
\par                   +--KEYF3DS (0xB000)
\par                      |
\par                      +--KEYF_UNKNWN01 (0xB00A)
\par                      +--............. (0x7001) ( viewport, same as editor )
\par                      +--KEYF_FRAMES   (0xB008)
\par                      +--KEYF_UNKNWN02 (0xB009)
\par                      +--KEYF_OBJDES   (0xB002)
\par                         |
\par                         +--KEYF_OBJHIERARCH  (0xB010)
\par                         +--KEYF_OBJDUMMYNAME (0xB011)
\par                         +--KEYF_OBJUNKNWN01  (0xB013)
\par                         +--KEYF_OBJUNKNWN02  (0xB014)
\par                         +--KEYF_OBJUNKNWN03  (0xB015)  
\par                         +--KEYF_OBJPIVOT     (0xB020)  
\par                         +--KEYF_OBJUNKNWN04  (0xB021)  
\par                         +--KEYF_OBJUNKNWN05  (0xB022)  
\par 
\par  
\par  A chunk type which you can find all through the file are the color chunks
\par  which are called:
\par 
\par  COL_RGB
\par  COL_TRU
\par  COL_UNK
\par 
\par 
\par 
\par                              2. Chunks anyone ?
\par                          =========================
\par 
\par  Now for the actual numbers, as you will see I used the define, because I
\par  ripped that part right out of my code. Be carefull however because there
\par  are a lot of new chunk types which were not documented in the original 
\par  paper by Jim Pitts.
\par 
\par  //------ Primary chunk
\par 
\par  #define MAIN3DS       0x4D4D
\par 
\par  //------ Main Chunks
\par 
\par  #define EDIT3DS       0x3D3D  // this is the start of the editor config
\par  #define KEYF3DS       0xB000  // this is the start of the keyframer config
\par 
\par  //------ sub defines of EDIT3DS
\par 
\par  #define EDIT_MATERIAL 0xAFFF
\par  #define EDIT_CONFIG1  0x0100
\par  #define EDIT_CONFIG2  0x3E3D
\par  #define EDIT_VIEW_P1  0x7012
\par  #define EDIT_VIEW_P2  0x7011
\par  #define EDIT_VIEW_P3  0x7020
\par  #define EDIT_VIEW1    0x7001
\par  #define EDIT_BACKGR   0x1200
\par  #define EDIT_AMBIENT  0x2100
\par  #define EDIT_OBJECT   0x4000
\par 
\par  #define EDIT_UNKNW01  0x1100
\par  #define EDIT_UNKNW02  0x1201
\par  #define EDIT_UNKNW03  0x1300
\par  #define EDIT_UNKNW04  0x1400
\par  #define EDIT_UNKNW05  0x1420
\par  #define EDIT_UNKNW06  0x1450
\par  #define EDIT_UNKNW07  0x1500
\par  #define EDIT_UNKNW08  0x2200
\par  #define EDIT_UNKNW09  0x2201
\par  #define EDIT_UNKNW10  0x2210
\par  #define EDIT_UNKNW11  0x2300
\par  #define EDIT_UNKNW12  0x2302 
\par  #define EDIT_UNKNW13  0x3000
\par  #define EDIT_UNKNW14  0xAFFF
\par 
\par  //------ sub defines of EDIT_OBJECT
\par  #define OBJ_TRIMESH   0x4100
\par  #define OBJ_LIGHT     0x4600
\par  #define OBJ_CAMERA    0x4700
\par 
\par  #define OBJ_UNKNWN01  0x4010
\par  #define OBJ_UNKNWN02  0x4012 //---- Could be shadow
\par 
\par  //------ sub defines of OBJ_CAMERA
\par  #define CAM_UNKNWN01  0x4710 
\par  #define CAM_UNKNWN02  0x4720 
\par 
\par  //------ sub defines of OBJ_LIGHT
\par  #define LIT_OFF       0x4620
\par  #define LIT_SPOT      0x4610
\par  #define LIT_UNKNWN01  0x465A
\par 
\par  //------ sub defines of OBJ_TRIMESH
\par  #define TRI_VERTEXL   0x4110
\par  #define TRI_FACEL2    0x4111 
\par  #define TRI_FACEL1    0x4120
\par  #define TRI_SMOOTH    0x4150
\par  #define TRI_LOCAL     0x4160
\par  #define TRI_VISIBLE   0x4165
\par 
\par  //------ sub defs of KEYF3DS
\par 
\par  #define KEYF_UNKNWN01 0xB009
\par  #define KEYF_UNKNWN02 0xB00A
\par  #define KEYF_FRAMES   0xB008
\par  #define KEYF_OBJDES   0xB002
\par 
\par  //------  these define the different color chunk types
\par  #define COL_RGB  0x0010
\par  #define COL_TRU  0x0011
\par  #define COL_UNK  0x0013
\par 
\par  //------ defines for viewport chunks
\par 
\par  #define TOP           0x0001
\par  #define BOTTOM        0x0002
\par  #define LEFT          0x0003
\par  #define RIGHT         0x0004
\par  #define FRONT         0x0005
\par  #define BACK          0x0006
\par  #define USER          0x0007
\par  #define CAMERA        0x0008 // 0xFFFF is the actual code read from file
\par  #define LIGHT         0x0009
\par  #define DISABLED      0x0010
\par  #define BOGUS         0x0011
\par 
\par 
\par 
\par  
\par                             3. 3D Editor Chunks
\par                        ===========================
\par 
\par  So far for the quick stuff now the more detailed info.
\par 
\par  * Main chunks
\par 
\par  The main chunk ( the primary chunk of 0x4D4D that is ) is actually the 
\par  complete file. So the size of this chunk is the size of the file minus
\par  the main chunk header.
\par 
\par  There are two more main chunks, the 3d-editor chunk and the keyframer 
\par  chunk:
\par 
\par    id
\par 
\par   3D3D Start of Editor data  ( this is also the place where the objects are )
\par   B000 Start of Keyframer data
\par 
\par   Directly after a Main chunk is another chunk. This could be any other type
\par   of chunk allowable within its main chunks scope. ( see diagram )
\par 
\par  * Subchunks of 3D3D
\par   id   Description
\par  0100  Part of configuration
\par  1100  unknown
\par  1200  Background Color
\par  1201  unknown
\par  1300  unknown
\par  1400  unknown
\par  1420  unknown
\par  1450  unknown
\par  1500  unknown
\par  2100  Ambient Color Block
\par  2200  fog ?
\par  2201  fog ?
\par  2210  fog ?
\par  2300  unknown
\par  3000  unknown
\par  3D3E  Editor configuration main block
\par  4000  Definition of an Object
\par  AFFF  Start of material list
\par 
\par  * Subchunks of AFFF - Start of material list
\par  * A000 - material name
\par  - This chunk contains the name of the material which is an ASCIIZ string
\par 
\par  ( 
\par    More material chunks are explained in the doc about 3d-studio .mli
\par    files. The chunk types mentioned in that doc are exactly the same
\par    as in the .3ds file
\par  )
\par 
\par  * Subchunks of 3D3E - Editor configuration
\par 
\par   id   Description
\par  7001  Start of viewport indicator
\par  7011  Viewport definition ( type 2 )
\par  7012  Viewport definition ( type 1 )
\par  7020  Viewport definition ( type 3 )
\par 
\par  The 3D3E chunk is a curious one because it contains a lot of redundant
\par  data. ( or so it seems ) The most important chunk is 7020. this chunk
\par  describes the 4 viewports wich are active in the editor. I assume that
\par  U are using the 4 normal viewport layout, because I have not tested it
\par  with other configurations. The editor confid will contain 5x chunk 7020
\par  and 5x chunk 7011. only the first 4 7020 chunks are important for how
\par  the viewports look like. I guess that the other chunks only give additional
\par  info, but I am not sure. The things you are looking for in these chunks is
\par  at byte: 6 & 7 ( as offset from the first 6 bytes chunk header and pointer )
\par  these bytes ( unsigned int ) contain the info at to what view is used, with
\par  the following id's:
\par 
\par   id    Description
\par  0001   Top
\par  0002   Bottom
\par  0003   Left
\par  0004   Right
\par  0005   Front
\par  0006   Back
\par  0007   User
\par  FFFF   Camera
\par  0009   Light
\par  0010   Disabled
\par 
\par  * Subchunks of 4000 - Object description Block
\par 
\par  - first item of Subchunk 4000 is an ASCIIZ string of the objects name.
\par    ASCIIZ means a string of charakters ended by a zero.
\par 
\par  Remember an Object can be a Camera a Light or a mesh
\par   id      Description
\par  4010     unknown
\par  4012     shadow ?
\par  4100     Triangular Polygon List ( Contains only subchunks )
\par  4600     Light
\par  4700     Camera
\par 
\par  ( Mapping:
\par 
\par    These chunks are optional. They stand just after the vertex list when
\par    the object is mapped. )
\par  
\par  * Subchunks of 4100 - Triangular Polygon List
\par 
\par   id      Description
\par  4110     Vertex List
\par  4111     Vertex Options
\par  4120     Face List
\par  4130     Face Material
\par  4140     Mapping Coordinates
\par  4150     Face smoothing group
\par  4160     Translation Matrix
\par  4165     Object visible/invisble
\par  4170     Standard Mapping
\par 
\par  * 4110 - Vertex List
\par 
\par    start end size type          name
\par    0     1    2   unsigned int  Total vertices in object
\par    2     5    4   float         X-value
\par    6     9    4   float         Y-value
\par   10    13    4   float         Z-value
\par 
\par  bytes 2..13 are repeated times the total amount of vertices in the object
\par 
\par  * 4111 - Vertex Options
\par 
\par  First 2 bytes: number of vertices.
\par 
\par  Then a short int for each vertex:
\par 
\par  bit 0-7    0
\par  bit 8-10   x
\par  bit 11-12  0
\par  bit 13   vertex selected in selection 3
\par  bit 14   vertex selected in selection 2
\par  bit 15   vertex selected in selection 1
\par 
\par  bit 8-10 are just like random. From a save to another of the same scene
\par  it may change.
\par  
\par  Other bits (0-7 and 11-12) have effects on visibility of vertex.
\par 
\par  The 4111 chunk can be deleted without much influence, 3ds will still load
\par  the file all right.
\par 
\par 
\par  * 4120 - Face list
\par 
\par  start end size type          name
\par  0     1    2   unsigned int  total polygons in object (numpoly)
\par 
\par  2     3    2   unsigned int  number of vertex A
\par  4     5    2   unsigned int  number of vertex B
\par  6     7    2   unsigned int  number of vertex C
\par  8     9    2   unsigned int  face info (*) 
\par 
\par  repeats 'numpoly' times for each polygon.
\par 
\par  The first three ints are the three vertices of the face.
\par  0 stands for the first vertex defined in the vertex list.
\par  The order has a purpose: to give the direction for the normal 
\par  of each face.
\par  If you turn a screw (standard screw) in the way the vertices 
\par  indicate you will find the normal.
\par  If vertices given in order are A B C:
\par 
\par                C
\par                ^
\par                |
\par         A-----B
\par 
\par  This means unscrewing = the normal points out of the screen.
\par 
\par  (*) this number is is a binary number which expands to 3 values.
\par      for example 0x0006 would expand to 110 binary. The value should be
\par      read as 1 1 0 .This value can be found in 3d-studio ascii files as
\par      AB:1 BC:1 AC:0 .Which probably indicated the order of the vertices.
\par      For example AB:1 would be a normal line from A to B. But AB:0 would
\par      mean a line from B to A.
\par 
\par      bit 0       AC visibility
\par      bit 1       BC visibility
\par      bit 2       AB visibility
\par      bit 3       Mapping (if there is mapping for this face)
\par      bit 4-8   0 (not used ?)
\par      bit 9-10  x (chaotic ???)
\par      bit 11-12 0 (not used ?)
\par      bit 13      face selected in selection 3
\par      bit 14      face selected in selection 2
\par      bit 15      face selected in selection 1
\par 
\par  * 4130 - Face Material Chunk 
\par 
\par    If the object is all default material there is no 4130 chunk.
\par    In fact, there is one 4130 chunk for each material present on the object.
\par 
\par    Each 4130 face material chunks begins with an asciiz of a material,
\par    then after the null character is a short int that gives the number
\par    of faces of the object concerned by this material, then there is the
\par    list itself of these faces. 0000 means the first face of the (4120) 
\par    face list.
\par 
\par    ************ Read the Doc on MLI files for more info on **************
\par    ************ Mapping and Materials                      **************
\par 
\par  * 4140 Mapping coordinates.
\par 
\par    First 2 bytes: number of vertices.
\par 
\par    Then, for each vertex 2 floats that give the mapping coordinates.
\par    That is, if a point is at the center of the map it will have 0.5 0.5
\par    as mapping coordinates.
\par 
\par  * 4150 - Face Smoothing Group
\par 
\par    nfaces*4bytes
\par 
\par    If read as long int, the nth bit indicate if the face belongs or not
\par    to the nth smoothing group.
\par 
\par  * 4160 Local axis
\par 
\par    Local axis info.
\par    The three first blocks of three floats are the definition
\par    (in the absolute axis) of the local axis X Y Z of the object.
\par    And the last block of three floats is the local center of the object.
\par  
\par  
\par  * 4170 Standard mapping
\par 
\par    First 2 bytes: type of mapping
\par    0 = plannar or specific (in this case, like mapping from the lofter,
\par                             the information of this chunk is irrelevant)
\par    1 = cylindrical
\par    2 = spherical
\par 
\par    then come 21 floats that describe the mapping.
\par 
\par * 4600 - Light
\par 
\par    start end size type   name
\par    0      3    4  float  Light pos X
\par    4      7    4  float  Light pos Y
\par    8     11    4  float  Light pos Z
\par 
\par    after this structure check for more chunks.
\par 
\par    id      Description ( full description later )
\par   0010     RGB color
\par   0011     24 bit color
\par   4610     Light is a Spot light
\par   4620     Light is off/on ( Boolean )
\par 
\par * 4610 - Spot Light
\par 
\par   start end size type   name
\par    0     3    4  float  Target pos X
\par    4     7    4  float  Target pos X
\par    8    11    4  float  Target pos X
\par   12    15    4  float  Hotspot
\par   16    19    4  float  Falloff
\par 
\par * 0010 - RGB Color
\par 
\par   start end size type   name
\par    0     3   4   float  Red
\par    4     7   4   float  Green
\par    8    11   4   float  Blue
\par 
\par * 0011 - RGB Color - 24 bit
\par 
\par   start end size type   name
\par    0    1    1   byte   Red
\par    1    1    1   byte   Green
\par    2    2    1   byte   Blue
\par 
\par * 4700 - Camera
\par 
\par  Describes the details of the camera in the scene
\par 
\par  start end size type   name
\par   0     3   4   float  Camera pos X
\par   4     7   4   float  Camera pos Y
\par   8    11   4   float  Camera pos Z
\par  12    15   4   float  Camera target X
\par  16    19   4   float  Camera target X
\par  20    23   4   float  Camera target X
\par  24    27   4   float  Camera bank ( rotation angle )
\par  28    31   4   float  Camera lens
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par                            4. Keyframer Chunks
\par                        ==========================
\par 
\par 
\par 
\par  * Keyframer chunk
\par 
\par   id         Description
\par  B00A        unknown
\par  7001        See first description of this chunk
\par  B008        Frames
\par  B009        unknown
\par  B002        Start object description
\par 
\par  * B008 - Frame information
\par 
\par  simple structure describing frame info
\par 
\par  start end size type            name
\par    0    3    4  unsigned long   start frame
\par    4    7    4  unsigned long   end frame
\par 
\par  *B002 - Start of Object info
\par 
\par  Subhunks
\par 
\par   id     Description
\par  B010    Name & Hierarchy
\par  B011*   Name Dummy Object
\par  B013    unknown
\par  B014*   unknown
\par  B015    unknown
\par  B020    Objects pivot point ?
\par  B021    unknown
\par  B022    unknown
\par 
\par  * B010 - Name & Hierarchy descriptor
\par 
\par  start end  size type          name
\par  0      ?    ?   ASCIIZ        Object name
\par  ?      ?    2   unsigned int  unknown
\par  ?      ?    2   unsigned int  unknown
\par  ?      ?    2   unsigned int  Hierarchy of Object
\par 
\par  The object hierarchy is a bit complex but works like this.
\par  Each Object in the scene is given a number to identify its
\par  order in the tree. Also each object is orddered in the 3ds
\par  file as it would appear in the tree.
\par  The root object is given the number -1 ( FFFF ).
\par  As the file is read a counter of the object number is kept.
\par  Is the counter increments the objects are children of the
\par  previous objects. But when the pattern is broken by a number
\par  what will be less than the current counter the hierarchy returns
\par  to that level.
\par 
\par  for example.
\par 
\par     object   hierarchy
\par     name
\par 
\par         A      -1
\par         B       0                 This example is taken
\par         C       1                 from 50pman.3ds
\par         D       2
\par         E       1                 I would really reccomend
\par         F       4                 having a look at one of the
\par         G       5                 examples with the hierarchy
\par         H       1                 numbers to help work it out.
\par         I       7
\par         J       8
\par         K       0
\par         L      10
\par         M      11
\par         N       0
\par         O      13
\par         P      14
\par 
\par 
\par                            A
\par          +-----------------+----------------+
\par          B                 K                N
\par     +----+----+            |                |
\par     C    E    H            L                O
\par     |    |    |            |                |
\par     D    F    I            M                P
\par          |    |
\par          G    J
\par 
\par  Still not done with this chunk yet !
\par  If the object name is $$$DUMMY then it is a dummy object
\par  and therefore you should expect a few extra chunks.
\par 
\par  * B011 - Dummy objects name.
\par 
\par     Names a dummy object. ASCIIZ string.
\par 
\par  * B020 - Pivot Point ?
\par 
\par  The Objects pivot point. Not quite sure what the first five floats do yet
\par  ( ideas ?).
\par 
\par  start end size type   name
\par    0    3    4  float  unknown
\par    4    7    4  float  unknown
\par    8   11    4  float  unknown
\par   12   16    4  float  unknown
\par   16   19    4  float  unknown
\par   20   23    4  float  unknown
\par   24   27    4  float  Pivot Y
\par   28   32    4  float  Pivot X
\par 
\par 
\par 
\par      
\par                                  5. CODE
\par                        =============================
\par 
\par  
\par  !!!!!!!!!!! The source code is not UP-TO-DATE it is written after rev 0.9
\par  of this Doc It will be updated when I can find the time ( or maybe YOU can)
\par  If the code looks like it has been written by a a twelve year old, then 
\par  looks do decieve, I like very simple and easy to read source code. All that
\par  matters is that it does the trick.
\par 
\par 
\par -----------------------------8}{\cs39\v\cf6 < cut here  >}{8-------------------------------
\par 
\par 
\par /*----------------------------------------------------------------------------*\\
\par      This is a lib which reads 3d-studio binary files from version 3.0
\par      and higher
\par      (v1.05)
\par      author: Martin van Velsen
\par              ( and some great help by Gert van der Spoel )
\par      email:  vvelsen@ronix.ptf.hro.nl
\par 
\par      If you happen to come across some variables with strange names, then
\par      that will possible be Dutch names, sorry for that :)
\par \\*----------------------------------------------------------------------------*/
\par #ifndef __3DSBIN_H__
\par #define __3DSBIN_H__
\par 
\par #include <stdio.h
\par #include <string.h
\par #include <stdlib.h
\par #include <conio.h   // IF you are on a dos system
\par #include <dos.h     // IF you are on a dos system
\par 
\par //------ tools
\par 
\par #define __DEBUG__          0
\par 
\par #define TRUE               0
\par #define FALSE              1
\par 
\par //------ Id Chunk
\par 
\par #define MAIN3DS       0x4D4D
\par 
\par //------ Main Chunks
\par 
\par #define EDIT3DS       0x3D3D  // this is the start of the editor config
\par #define KEYF3DS       0xB000  // this is the start of the keyframer config
\par 
\par //------ sub defines of EDIT3DS
\par 
\par #define EDIT_MATERIAL 0xAFFF
\par #define EDIT_CONFIG1  0x0100
\par #define EDIT_CONFIG2  0x3E3D
\par #define EDIT_VIEW_P1  0x7012
\par #define EDIT_VIEW_P2  0x7011
\par #define EDIT_VIEW_P3  0x7020
\par #define EDIT_VIEW1    0x7001
\par #define EDIT_BACKGR   0x1200
\par #define EDIT_AMBIENT  0x2100
\par #define EDIT_OBJECT   0x4000
\par 
\par #define EDIT_UNKNW01  0x1100
\par #define EDIT_UNKNW02  0x1201
\par #define EDIT_UNKNW03  0x1300
\par #define EDIT_UNKNW04  0x1400
\par #define EDIT_UNKNW05  0x1420
\par #define EDIT_UNKNW06  0x1450
\par #define EDIT_UNKNW07  0x1500
\par #define EDIT_UNKNW08  0x2200
\par #define EDIT_UNKNW09  0x2201
\par #define EDIT_UNKNW10  0x2210
\par #define EDIT_UNKNW11  0x2300
\par #define EDIT_UNKNW12  0x2302 // new chunk type
\par #define EDIT_UNKNW13  0x3000
\par #define EDIT_UNKNW14  0xAFFF
\par 
\par //------ sub defines of EDIT_MATERIAL
\par #define MAT_NAME01    0xA000  // includes name (see mli doc for materials)
\par 
\par //------ sub defines of EDIT_OBJECT
\par 
\par #define OBJ_TRIMESH   0x4100
\par #define OBJ_LIGHT     0x4600
\par #define OBJ_CAMERA    0x4700
\par 
\par #define OBJ_UNKNWN01  0x4010
\par #define OBJ_UNKNWN02  0x4012 //---- Could be shadow
\par 
\par //------ sub defines of OBJ_CAMERA
\par #define CAM_UNKNWN01  0x4710 // new chunk type
\par #define CAM_UNKNWN02  0x4720 // new chunk type
\par 
\par //------ sub defines of OBJ_LIGHT
\par #define LIT_OFF       0x4620
\par #define LIT_SPOT      0x4610
\par #define LIT_UNKNWN01  0x465A
\par 
\par //------ sub defines of OBJ_TRIMESH
\par #define TRI_VERTEXL   0x4110
\par #define TRI_FACEL2    0x4111 // unknown yet
\par #define TRI_FACEL1    0x4120
\par #define TRI_SMOOTH    0x4150
\par #define TRI_LOCAL     0x4160
\par #define TRI_VISIBLE   0x4165
\par 
\par //------ sub defs of KEYF3DS
\par 
\par #define KEYF_UNKNWN01 0xB009
\par #define KEYF_UNKNWN02 0xB00A
\par #define KEYF_FRAMES   0xB008
\par #define KEYF_OBJDES   0xB002
\par 
\par #define KEYF_OBJHIERARCH  0xB010
\par #define KEYF_OBJDUMMYNAME 0xB011
\par #define KEYF_OBJUNKNWN01  0xB013
\par #define KEYF_OBJUNKNWN02  0xB014
\par #define KEYF_OBJUNKNWN03  0xB015  
\par #define KEYF_OBJPIVOT     0xB020  
\par #define KEYF_OBJUNKNWN04  0xB021  
\par #define KEYF_OBJUNKNWN05  0xB022  
\par 
\par //------  these define the different color chunk types
\par #define COL_RGB  0x0010
\par #define COL_TRU  0x0011
\par #define COL_UNK  0x0013 // unknown
\par 
\par //------ defines for viewport chunks
\par 
\par #define TOP           0x0001
\par #define BOTTOM        0x0002
\par #define LEFT          0x0003
\par #define RIGHT         0x0004
\par #define FRONT         0x0005
\par #define BACK          0x0006
\par #define USER          0x0007
\par #define CAMERA        0x0008 // 0xFFFF is the code read from file
\par #define LIGHT         0x0009
\par #define DISABLED      0x0010
\par #define BOGUS         0x0011
\par 
\par //------ global vars
\par 
\par char *viewports [11]=\{
\par                       "Bogus",
\par                       "Top",
\par                       "Bottom",
\par                       "Left",
\par                       "Right",
\par                       "Front",
\par                       "Back",
\par                       "User",
\par                       "Camera",
\par                       "Light",
\par                       "Disabled"
\par                      \};
\par 
\par FILE *bin3ds;
\par unsigned long current_chunk=0L;
\par unsigned char views_read=0;
\par unsigned int numb_faces=0,numb_vertices=0;
\par char temp_name [100];
\par float trans_mat [4][4]; // translation matrix for objects
\par 
\par #endif
\par 
\par 
\par 
\par -----------------------------8}{\cs39\v\cf6 < cut here  >}{8-------------------------------
\par 
\par 
\par /*----------------------------------------------------------------------------*\\
\par      This is a lib which reads 3d-studio binary files from version 3.0
\par      and higher
\par      (v1.05)
\par      author: Martin van Velsen
\par              ( and some great help by Gert van der Spoel )
\par      email:  vvelsen@ronix.ptf.hro.nl
\par  
\par      If you happen to come across some variables with strange names, then
\par      that will possible be Dutch names, sorry for that :)
\par 
\par \\*----------------------------------------------------------------------------*/
\par #ifndef __3DSBIN_C__
\par #define __3DSBIN_C__
\par 
\par #include "3ds_bin.h"
\par 
\par /*----------------------------------------------------------------------------*/
\par unsigned char ReadChar (void)
\par \{
\par  return (fgetc (bin3ds));
\par 
\par  //------ if you want to add some code to create a progress bar, then
\par  //------ I suggest you do it here. This is the only function which
\par  //------ reads from disk
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned int ReadInt (void)
\par \{
\par  unsigned int temp = ReadChar();
\par  return ( temp | (ReadChar () << 8));
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadLong (void)
\par \{
\par  unsigned long temp1,temp2;
\par  unsigned long temp3,temp4;
\par 
\par  temp1=ReadInt ();
\par  temp2=ReadInt ();
\par 
\par  return (temp3+(temp4*0x10000L));
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadChunkPointer (void)
\par \{
\par  return (ReadLong ());
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long GetChunkPointer (void)
\par \{
\par  return (ftell (bin3ds)-2); // compensate for the already read Marker
\par \}
\par /*----------------------------------------------------------------------------*/
\par void ChangeChunkPointer (unsigned long temp_pointer)
\par \{
\par  fseek (bin3ds,temp_pointer,SEEK_SET);
\par \}
\par /*----------------------------------------------------------------------------*/
\par int ReadName (void)
\par \{
\par  unsigned int teller=0;
\par  unsigned char letter;
\par 
\par  strcpy (temp_name,"Default name");
\par 
\par  letter=ReadChar ();
\par  if (letter==0) return (-1); // dummy object
\par  temp_name [teller]=letter;
\par  teller++;
\par 
\par  do
\par  \{
\par   letter=ReadChar ();
\par   temp_name [teller]=letter;
\par   teller++;
\par  \}
\par  while ((letter!=0) && (teller<12));
\par 
\par  temp_name [teller-1]=0;
\par 
\par  #ifdef __DEBUG__
\par   printf ("     Found name : %s\\n",temp_name);
\par  #endif
\par  return (0);
\par \}
\par /*----------------------------------------------------------------------------*/
\par int ReadLongName (void)
\par \{
\par  unsigned int teller=0;
\par  unsigned char letter;
\par 
\par  strcpy (temp_name,"Default name");
\par 
\par  letter=ReadChar ();
\par  if (letter==0) return (-1); // dummy object
\par  temp_name [teller]=letter;
\par  teller++;
\par 
\par  do
\par  \{
\par   letter=ReadChar ();
\par   temp_name [teller]=letter;
\par   teller++;
\par  \}
\par  while (letter!=0);
\par 
\par  temp_name [teller-1]=0;
\par 
\par  #ifdef __DEBUG__
\par    printf ("Found name : %s\\n",temp_name);
\par  #endif
\par  return (0);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadUnknownChunk (unsigned int chunk_id)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par 
\par  chunk_id=chunk_id;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadRGBColor (void)
\par \{
\par  float rgb_val [3];
\par 
\par  for (int i=0;i<3;i++)
\par   fread (&(rgb_val [i]),sizeof (float),1,bin3ds);
\par 
\par  #ifdef __DEBUG__
\par  printf ("     Found Color (RGB) def of: R:%5.2f,G:%5.2f,B:%5.2f\\n",
\par           rgb_val [0],
\par           rgb_val [1],
\par           rgb_val [2]);
\par  #endif
\par 
\par  return (12L);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadTrueColor (void)
\par \{
\par  unsigned char true_c_val [3];
\par 
\par  for (int i=0;i<3;i++)
\par   true_c_val [i]=ReadChar ();
\par 
\par  #ifdef __DEBUG__
\par  printf ("     Found Color (24bit) def of: R:%d,G:%d,B:%d\\n",
\par           true_c_val [0],
\par           true_c_val [1],
\par           true_c_val [2]);
\par  #endif
\par 
\par  return (3L);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadBooleanChunk (unsigned char *boolean)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  *boolean=ReadChar ();
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadSpotChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  float target [4];
\par  float hotspot,falloff;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  fread (&(target [0]),sizeof (float),1,bin3ds);
\par  fread (&(target [1]),sizeof (float),1,bin3ds);
\par  fread (&(target [2]),sizeof (float),1,bin3ds);
\par  fread (&hotspot,sizeof (float),1,bin3ds);
\par  fread (&falloff,sizeof (float),1,bin3ds);
\par 
\par  #ifdef __DEBUG__
\par  printf ("      The target of the spot is at: X:%5.2f Y:%5.2f Y:%5.2f\\n",
\par           target [0],
\par           target [1],
\par           target [2]);
\par  printf ("      The hotspot of this light is : %5.2f\\n",hotspot);
\par  printf ("      The falloff of this light is : %5.2f\\n",falloff);
\par  #endif
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadLightChunk (void)
\par \{
\par  unsigned char end_found=FALSE,boolean;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L; // 2 id + 4 pointer
\par  float light_coors [3];
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  fread (&(light_coors [0]),sizeof (float),1,bin3ds);
\par  fread (&(light_coors [1]),sizeof (float),1,bin3ds);
\par  fread (&(light_coors [2]),sizeof (float),1,bin3ds);
\par 
\par  #ifdef __DEBUG__
\par  printf ("     Found light at coordinates: X: %5.2f, Y: %5.2f,Z: %5.2f\\n",
\par           light_coors [0],
\par           light_coors [1],
\par           light_coors [2]);
\par  #endif
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case LIT_UNKNWN01 :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Light unknown chunk id of %0X\\n",LIT_UNKNWN01);
\par                            #endif
\par                            tellertje+=ReadUnknownChunk (LIT_UNKNWN01);
\par                            break;
\par         case LIT_OFF      :
\par                            #ifdef __DEBUG__
\par                            printf (" Light is (on/off) chunk: %0X\\n",LIT_OFF);
\par                            #endif
\par                            tellertje+=ReadBooleanChunk (&boolean);
\par                            #ifdef __DEBUG__
\par                            if (boolean==TRUE)
\par                              printf ("      Light is on\\n");
\par                            else
\par                              printf ("      Light is off\\n");
\par                            #endif
\par                            break;
\par         case LIT_SPOT     :
\par                            #ifdef __DEBUG__
\par                            printf (" Light is SpotLight: %0X\\n",TRI_VERTEXL);
\par                            #endif
\par                            tellertje+=ReadSpotChunk ();
\par                            break;
\par         case COL_RGB      :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Color def (RGB) chunk id of %0X\\n",temp_int);
\par                            #endif
\par                            tellertje+=ReadRGBColor ();
\par                            break;
\par         case COL_TRU      :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Color def (24bit) chunk id of %0X\\n",temp_int);
\par                            #endif
\par                            tellertje+=ReadTrueColor ();
\par                            break;
\par         default           :break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadCameraChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  float camera_eye [3];
\par  float camera_focus [3];
\par  float rotation,lens;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  fread (&(camera_eye [0]),sizeof (float),1,bin3ds);
\par  fread (&(camera_eye [1]),sizeof (float),1,bin3ds);
\par  fread (&(camera_eye [2]),sizeof (float),1,bin3ds);
\par 
\par  #ifdef __DEBUG__
\par  printf ("     Found Camera viewpoint at coordinates: X: %5.2f, Y: %5.2f,Z: %5.2f\\n",
\par           camera_eye [0],
\par           camera_eye [1],
\par           camera_eye [2]);
\par  #endif
\par 
\par  fread (&(camera_focus [0]),sizeof (float),1,bin3ds);
\par  fread (&(camera_focus [1]),sizeof (float),1,bin3ds);
\par  fread (&(camera_focus [2]),sizeof (float),1,bin3ds);
\par 
\par  #ifdef __DEBUG__
\par  printf ("     Found Camera focus coors at coordinates: X: %5.2f, Y: %5.2f,Z: %5.2f\\n",
\par           camera_focus [0],
\par           camera_focus [1],
\par           camera_focus [2]);
\par  #endif
\par 
\par  fread (&rotation,sizeof (float),1,bin3ds);
\par  fread (&lens,sizeof (float),1,bin3ds);
\par  #ifdef __DEBUG__
\par  printf ("     Rotation of camera is:  %5.4f\\n",rotation);
\par  printf ("     Lens in used camera is: %5.4fmm\\n",lens);
\par  #endif
\par 
\par  if ((temp_pointer-38)0) // this means more chunks are to follow
\par  \{
\par   #ifdef __DEBUG__
\par   printf ("     **** found extra cam chunks ****\\n");
\par   #endif
\par   if (ReadInt ()==CAM_UNKNWN01)
\par   \{
\par    #ifdef __DEBUG__
\par    printf ("     **** Found cam 1 type ch ****\\n");
\par    #endif
\par    ReadUnknownChunk (CAM_UNKNWN01);
\par   \}
\par   if (ReadInt ()==CAM_UNKNWN02)
\par   \{
\par    #ifdef __DEBUG__
\par    printf ("     **** Found cam 2 type ch ****\\n");
\par    #endif
\par    ReadUnknownChunk (CAM_UNKNWN02);
\par   \}
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadVerticesChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  float vertices [3]; // x,y,z
\par  unsigned int numb_v;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par  numb_vertices  =ReadInt ();
\par 
\par  #ifdef __DEBUG__
\par  printf ("      Found (%d) number of vertices\\n",numb_vertices);
\par  #endif
\par 
\par  for (int i=0;i<numb_vertices;i++)
\par  \{
\par   fread (&(vertices [0]),sizeof (float),1,bin3ds);
\par   fread (&(vertices [1]),sizeof (float),1,bin3ds);
\par   fread (&(vertices [2]),sizeof (float),1,bin3ds);
\par 
\par   #ifdef __DEBUG__
\par   printf ("      Vertex nr%4d: X: %5.2f  Y: %5.2f  Z:%5.2f\\n",
\par            i,
\par            vertices [0],
\par            vertices [1],
\par            vertices [2]);
\par   #endif
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/ 
\par unsigned long ReadSmoothingChunk ()
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long smoothing;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  for (int i=0;i<numb_faces;i++)
\par  \{
\par   smoothing=ReadLong();
\par   smoothing=smoothing; // compiler warnig depressor *:)
\par   #ifdef __DEBUG__
\par   printf ("      The smoothing group for face [%5d] is %d\\n",i,smoothing);
\par   #endif
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadFacesChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned int temp_diff;
\par  unsigned int faces [6]; // a,b,c,Diff (Diff= AB: BC: CA: )
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par  numb_faces     =ReadInt ();
\par  #ifdef __DEBUG__
\par  printf ("      Found (%d) number of faces\\n",numb_faces);
\par  #endif
\par 
\par  for (int i=0;i<numb_faces;i++)
\par  \{
\par   faces [0]=ReadInt ();
\par   faces [1]=ReadInt ();
\par   faces [2]=ReadInt ();
\par   temp_diff=ReadInt () & 0x000F;
\par   faces [3]=(temp_diff & 0x0004)  2;
\par   faces [4]=(temp_diff & 0x0002)  1;
\par   faces [5]=(temp_diff & 0x0001);
\par 
\par   #ifdef __DEBUG__
\par   printf ("      Face nr:%d, A: %d  B: %d  C:%d , AB:%d  BC:%d  CA:%d\\n",
\par            i,
\par            faces [0],
\par            faces [1],
\par            faces [2],
\par            faces [3],
\par            faces [4],
\par            faces [5]);
\par   #endif
\par  \}
\par 
\par  if (ReadInt ()==TRI_SMOOTH)
\par   ReadSmoothingChunk ();
\par  #ifdef __DEBUG__
\par  else
\par   printf ("      No smoothing groups found, assuming autosmooth\\n");
\par  #endif
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadTranslationChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  for (int j=0;j<4;j++)
\par  \{
\par    for (int i=0;i<3;i++)
\par     fread (&(trans_mat [j][i]),sizeof (float),1,bin3ds);
\par  \}
\par 
\par  trans_mat [0][3]=0;
\par  trans_mat [1][3]=0;
\par  trans_mat [2][3]=0;
\par  trans_mat [3][3]=1;
\par 
\par  #ifdef __DEBUG__
\par  printf ("     The translation matrix is:\\n");
\par  for (int i=0;i<4;i++)
\par      printf ("      | %5.2f %5.2f %5.2f %5.2f |\\n",
\par               trans_mat [i][0],
\par               trans_mat [i][1],
\par               trans_mat [i][2],
\par               trans_mat [i][3]);
\par  #endif
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadObjChunk (void)
\par \{
\par  unsigned char end_found=FALSE,boolean=TRUE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L; // 2 id + 4 pointer
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case TRI_VERTEXL :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Object vertices chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadVerticesChunk ();
\par                           break;
\par         case TRI_FACEL1  :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Object faces (1) chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadFacesChunk ();
\par                           break;
\par         case TRI_FACEL2  :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Object faces (2) chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadUnknownChunk (temp_int);
\par                           break;
\par         case TRI_LOCAL  :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Object translation chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadTranslationChunk ();
\par                           break;
\par         case TRI_VISIBLE :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Object vis/invis chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadBooleanChunk (&boolean);
\par 
\par                           #ifdef __DEBUG__
\par                           if (boolean==TRUE)
\par                              printf ("      Object is (visible)\\n");
\par                           else
\par                              printf ("      Object is (not visible)\\n");
\par                           #endif
\par                           break;
\par         default:          break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadObjectChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L; // 2 id + 4 pointer
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  if (ReadName ()==-1)
\par  \{
\par   #ifdef __DEBUG__
\par   printf ("* Dummy Object found\\n");
\par   #endif
\par  \}
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case OBJ_UNKNWN01:tellertje+=ReadUnknownChunk (OBJ_UNKNWN01);break;
\par         case OBJ_UNKNWN02:tellertje+=ReadUnknownChunk (OBJ_UNKNWN02);break;
\par         case OBJ_TRIMESH :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Obj/Mesh chunk id of %0X\\n",
\par                                   OBJ_TRIMESH);
\par                           #endif
\par                           tellertje+=ReadObjChunk ();
\par                           break;
\par         case OBJ_LIGHT   :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Light chunk id of %0X\\n",
\par                                   OBJ_LIGHT);
\par                           #endif
\par                           tellertje+=ReadLightChunk ();
\par                           break;
\par         case OBJ_CAMERA  :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Camera chunk id of %0X\\n",
\par                                   OBJ_CAMERA);
\par                           #endif
\par                           tellertje+=ReadCameraChunk ();
\par                           break;
\par         default:          break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadBackgrChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L; // 2 id + 4 pointer
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case COL_RGB :
\par                       #ifdef __DEBUG__
\par                       printf (" Found Color def (RGB) chunk id of %0X\\n",
\par                               temp_int);
\par                       #endif
\par                       tellertje+=ReadRGBColor ();
\par                       break;
\par         case COL_TRU :
\par                       #ifdef __DEBUG__
\par                       printf (" Found Color def (24bit) chunk id of %0X\\n",
\par                               temp_int);
\par                       #endif
\par                       tellertje+=ReadTrueColor ();
\par                       break;
\par         default:      break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadAmbientChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L; // 2 id + 4 pointer
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case COL_RGB :
\par                       #ifdef __DEBUG__
\par                       printf (" Found Color def (RGB) chunk id of %0X\\n",
\par                               temp_int);
\par                       #endif
\par                       tellertje+=ReadRGBColor ();
\par                       break;
\par         case COL_TRU :
\par                       #ifdef __DEBUG__
\par                       printf (" Found Color def (24bit) chunk id of %0X\\n",
\par                               temp_int);
\par                       #endif
\par                       tellertje+=ReadTrueColor ();
\par                       break;
\par         default:      break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long FindCameraChunk (void)
\par \{
\par  long temp_pointer=0L;
\par 
\par  for (int i=0;i<12;i++)
\par   ReadInt ();
\par 
\par  temp_pointer=11L;
\par  temp_pointer=ReadName ();
\par 
\par  #ifdef __DEBUG__
\par  if (temp_pointer==-1)
\par    printf ("* No Camera name found\\n");
\par  #endif
\par 
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadViewPortChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned int port,attribs;
\par 
\par  views_read++;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  attribs=ReadInt ();
\par  if (attribs==3)
\par  \{
\par   #ifdef __DEBUG__
\par   printf ("}{\cs39\v\cf6 <Snap>}{ active in viewport\\n");
\par   #endif
\par  \}
\par  if (attribs==5)
\par  \{
\par   #ifdef __DEBUG__
\par   printf ("}{\cs39\v\cf6 <Grid>}{ active in viewport\\n");
\par   #endif
\par  \}
\par 
\par  for (int i=1;i<6;i++) ReadInt (); // read 5 ints to get to the viewport
\par 
\par  port=ReadInt ();
\par  if ((port==0xFFFF) || (port==0))
\par  \{
\par    FindCameraChunk ();
\par    port=CAMERA;
\par  \}
\par 
\par  #ifdef __DEBUG__
\par  printf ("Reading [%s] information with id:%d\\n",viewports [port],port);
\par  #endif
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadViewChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case EDIT_VIEW_P1 :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Viewport1 chunk id of %0X\\n",
\par                                    temp_int);
\par                            #endif
\par                            tellertje+=ReadViewPortChunk ();
\par                            break;
\par         case EDIT_VIEW_P2 :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Viewport2 (bogus) chunk id of %0X\\n",
\par                                    temp_int);
\par                            #endif
\par                            tellertje+=ReadUnknownChunk (EDIT_VIEW_P2);
\par                            break;
\par        case EDIT_VIEW_P3 :
\par                            #ifdef __DEBUG__
\par                            printf (" Found Viewport chunk id of %0X\\n",
\par                                    temp_int);
\par                            #endif
\par                            tellertje+=ReadViewPortChunk ();
\par                            break;
\par         default           :break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par 
\par    if (views_read3)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadMatDefChunk (void)
\par \{
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  if (ReadLongName ()==-1)
\par  \{
\par    #ifdef __DEBUG__
\par    printf ("* No Material name found\\n");
\par    #endif
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadMaterialChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case MAT_NAME01  :
\par                           #ifdef __DEBUG__
\par                           printf (" Found Material def chunk id of %0X\\n",
\par                                   temp_int);
\par                           #endif
\par                           tellertje+=ReadMatDefChunk ();
\par                           break;
\par         default:break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadEditChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case EDIT_UNKNW01:tellertje+=ReadUnknownChunk (EDIT_UNKNW01);break;
\par         case EDIT_UNKNW02:tellertje+=ReadUnknownChunk (EDIT_UNKNW02);break;
\par         case EDIT_UNKNW03:tellertje+=ReadUnknownChunk (EDIT_UNKNW03);break;
\par         case EDIT_UNKNW04:tellertje+=ReadUnknownChunk (EDIT_UNKNW04);break;
\par         case EDIT_UNKNW05:tellertje+=ReadUnknownChunk (EDIT_UNKNW05);break;
\par         case EDIT_UNKNW06:tellertje+=ReadUnknownChunk (EDIT_UNKNW06);break;
\par         case EDIT_UNKNW07:tellertje+=ReadUnknownChunk (EDIT_UNKNW07);break;
\par         case EDIT_UNKNW08:tellertje+=ReadUnknownChunk (EDIT_UNKNW08);break;
\par         case EDIT_UNKNW09:tellertje+=ReadUnknownChunk (EDIT_UNKNW09);break;
\par         case EDIT_UNKNW10:tellertje+=ReadUnknownChunk (EDIT_UNKNW10);break;
\par         case EDIT_UNKNW11:tellertje+=ReadUnknownChunk (EDIT_UNKNW11);break;
\par         case EDIT_UNKNW12:tellertje+=ReadUnknownChunk (EDIT_UNKNW12);break;
\par         case EDIT_UNKNW13:tellertje+=ReadUnknownChunk (EDIT_UNKNW13);break;
\par 
\par         case EDIT_MATERIAL :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Materials chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadMaterialChunk ();
\par                             break;
\par         case EDIT_VIEW1    :
\par                             #ifdef __DEBUG__
\par                             printf (" Found View main def chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadViewChunk ();
\par                             break;
\par         case EDIT_BACKGR   :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Backgr chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadBackgrChunk ();
\par                             break;
\par         case EDIT_AMBIENT  :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Ambient chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadAmbientChunk ();
\par                             break;
\par         case EDIT_OBJECT   :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Object chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadObjectChunk ();
\par                             break;
\par         default:            break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadKeyfChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case KEYF_UNKNWN01 :tellertje+=ReadUnknownChunk (temp_int);break;
\par         case KEYF_UNKNWN02 :tellertje+=ReadUnknownChunk (temp_int);break;
\par         case KEYF_FRAMES   :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Keyframer frames chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadUnknownChunk (temp_int);
\par                             break;
\par         case KEYF_OBJDES   :
\par                             #ifdef __DEBUG__
\par                             printf (" Found Keyframer object description chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadUnknownChunk (temp_int);
\par                             break;
\par         case EDIT_VIEW1    :
\par                             #ifdef __DEBUG__
\par                             printf (" Found View main def chunk id of %0X\\n",
\par                                     temp_int);
\par                             #endif
\par                             tellertje+=ReadViewChunk ();
\par                             break;
\par         default:            break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par      end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par unsigned long ReadMainChunk (void)
\par \{
\par  unsigned char end_found=FALSE;
\par  unsigned int temp_int;
\par  unsigned long current_pointer;
\par  unsigned long temp_pointer;
\par  unsigned long tellertje=6L;
\par 
\par  current_pointer=GetChunkPointer ();
\par  temp_pointer   =ReadChunkPointer ();
\par 
\par  while (end_found==FALSE)
\par  \{
\par    temp_int=ReadInt ();
\par 
\par        switch (temp_int)
\par        \{
\par         case KEYF3DS :
\par                       #ifdef __DEBUG__
\par                       printf (" Found *Keyframer* chunk id of %0X\\n",KEYF3DS);
\par                       #endif
\par                       tellertje+=ReadKeyfChunk ();
\par                       break;
\par         case EDIT3DS :
\par                       #ifdef __DEBUG__
\par                       printf (" Found *Editor* chunk id of %0X\\n",EDIT3DS);
\par                       #endif
\par                       tellertje+=ReadEditChunk ();
\par                       break;
\par         default:      break;
\par        \}
\par 
\par    tellertje+=2;
\par    if (tellertje=temp_pointer)
\par     end_found=TRUE;
\par  \}
\par 
\par  ChangeChunkPointer (current_pointer+temp_pointer); 
\par  // move to the new chunk position
\par  return (temp_pointer);
\par \}
\par /*----------------------------------------------------------------------------*/
\par int ReadPrimaryChunk (void)
\par \{
\par  unsigned char version;
\par 
\par  if (ReadInt ()==MAIN3DS)
\par  \{
\par   #ifdef __DEBUG__
\par   printf (" Found Main chunk id of %0X\\n",MAIN3DS);
\par   #endif
\par   //---------- find version number
\par   fseek (bin3ds,28L,SEEK_SET);
\par   version=ReadChar ();
\par   if (version<3)
\par   \{
\par    #ifdef __DEBUG__
\par    printf ("Sorry this lib can only read 3ds files of version 3.0 and higher\\n");
\par    printf ("The version of the file you want to read is: %d\\n",version);
\par    #endif
\par    return (1);
\par   \}
\par   fseek (bin3ds,2,SEEK_SET);
\par   ReadMainChunk ();
\par  \}
\par  else
\par   return (1);
\par 
\par  return (0);
\par \}
\par /*----------------------------------------------------------------------------*/
\par /*                      Test Main for the 3ds-bin lib                         */
\par /*----------------------------------------------------------------------------*/
\par int main (int argc,char **argv)
\par \{
\par  argc=argc;
\par 
\par  bin3ds=fopen (argv [1],"rb");
\par  if (bin3ds==NULL)
\par   return (-1);
\par 
\par  #ifdef __DEBUG__
\par   printf ("\\nLoading 3ds binary file : %s\\n",argv [1]);
\par  #endif
\par  while (ReadPrimaryChunk ()==0);
\par 
\par  return (0);
\par \}
\par /*----------------------------------------------------------------------------*/
\par #endif
\par 
\par }}